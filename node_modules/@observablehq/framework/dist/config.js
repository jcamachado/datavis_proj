import { createHash } from "node:crypto";
import { existsSync, readFileSync } from "node:fs";
import { stat } from "node:fs/promises";
import op from "node:path";
import { basename, dirname, join } from "node:path/posix";
import { cwd } from "node:process";
import { pathToFileURL } from "node:url";
import { LoaderResolver } from "./dataloader.js";
import { visitMarkdownFiles } from "./files.js";
import { formatIsoDate, formatLocaleDate } from "./format.js";
import { createMarkdownIt, parseMarkdownMetadata } from "./markdown.js";
import { isAssetPath, parseRelativeUrl, resolvePath } from "./path.js";
import { resolveTheme } from "./theme.js";
function resolveConfig(configPath, root = ".") {
  return op.join(cwd(), root, configPath);
}
async function importConfig(path) {
  const { mtimeMs } = await stat(path);
  return (await import(`${pathToFileURL(path).href}?${mtimeMs}`)).default;
}
async function readConfig(configPath, root) {
  if (configPath === void 0)
    configPath = await resolveDefaultConfig(root);
  if (configPath === void 0)
    return normalizeConfig(void 0, root);
  return normalizeConfig(await importConfig(configPath), root, configPath);
}
async function resolveDefaultConfig(root) {
  const jsPath = resolveConfig("observablehq.config.js", root);
  if (existsSync(jsPath))
    return jsPath;
  const tsPath = resolveConfig("observablehq.config.ts", root);
  if (existsSync(tsPath))
    return await import("tsx/esm"), tsPath;
}
let cachedPages = null;
function readPages(root, md) {
  const files = [];
  const hash = createHash("sha256");
  for (const file of visitMarkdownFiles(root)) {
    if (file === "index.md" || file === "404.md")
      continue;
    const source = readFileSync(join(root, file), "utf8");
    files.push({ file, source });
    hash.update(file).update(source);
  }
  const key = hash.digest("hex");
  if (cachedPages?.key === key)
    return cachedPages.pages;
  const pages = [];
  for (const { file, source } of files) {
    const { data, title } = parseMarkdownMetadata(source, { path: file, md });
    if (data.draft)
      continue;
    const name = basename(file, ".md");
    const page = { path: join("/", dirname(file), name), name: title ?? "Untitled" };
    if (name === "index")
      pages.unshift(page);
    else
      pages.push(page);
  }
  cachedPages = { key, pages };
  return pages;
}
let currentDate = /* @__PURE__ */ new Date();
function setCurrentDate(date = /* @__PURE__ */ new Date()) {
  currentDate = date;
}
const configCache = /* @__PURE__ */ new WeakMap();
function normalizeConfig(spec = {}, defaultRoot = "docs", watchPath) {
  const cachedConfig = configCache.get(spec);
  if (cachedConfig)
    return cachedConfig;
  let {
    root = defaultRoot,
    output = "dist",
    base = "/",
    sidebar,
    style,
    theme = "default",
    search,
    deploy,
    scripts = [],
    head = "",
    header = "",
    footer = `Built with <a href="https://observablehq.com/" target="_blank">Observable</a> on <a title="${formatIsoDate(
      currentDate
    )}">${formatLocaleDate(currentDate)}</a>.`,
    interpreters
  } = spec;
  root = String(root);
  output = String(output);
  base = normalizeBase(base);
  if (style === null)
    style = null;
  else if (style !== void 0)
    style = { path: String(style) };
  else
    style = { theme: theme = normalizeTheme(theme) };
  const md = createMarkdownIt(spec);
  let { title, pages, pager = true, toc = true } = spec;
  if (title !== void 0)
    title = String(title);
  if (pages !== void 0)
    pages = Array.from(pages, normalizePageOrSection);
  if (sidebar !== void 0)
    sidebar = Boolean(sidebar);
  pager = Boolean(pager);
  scripts = Array.from(scripts, normalizeScript);
  head = String(head);
  header = String(header);
  footer = String(footer);
  toc = normalizeToc(toc);
  deploy = deploy ? { workspace: String(deploy.workspace).replace(/^@+/, ""), project: String(deploy.project) } : null;
  search = Boolean(search);
  interpreters = normalizeInterpreters(interpreters);
  const config = {
    root,
    output,
    base,
    title,
    sidebar,
    pages,
    pager,
    scripts,
    head,
    header,
    footer,
    toc,
    style,
    deploy,
    search,
    md,
    loaders: new LoaderResolver({ root, interpreters }),
    watchPath
  };
  if (pages === void 0)
    Object.defineProperty(config, "pages", { get: () => readPages(root, md) });
  if (sidebar === void 0)
    Object.defineProperty(config, "sidebar", { get: () => config.pages.length > 0 });
  configCache.set(spec, config);
  return config;
}
function normalizeBase(base) {
  base = String(base);
  if (!base.startsWith("/"))
    throw new Error(`base must start with slash: ${base}`);
  if (!base.endsWith("/"))
    base += "/";
  return base;
}
function normalizeTheme(spec) {
  return resolveTheme(typeof spec === "string" ? [spec] : spec === null ? [] : Array.from(spec, String));
}
function normalizeScript(spec) {
  if (typeof spec === "string")
    spec = { src: spec };
  let { src, async = false, type } = spec;
  src = String(src);
  async = Boolean(async);
  type = type == null ? null : String(type);
  return { src, async, type };
}
function normalizePageOrSection(spec) {
  return ("pages" in spec ? normalizeSection : normalizePage)(spec);
}
function normalizeSection(spec) {
  let { name, open = true, pages } = spec;
  name = String(name);
  open = Boolean(open);
  pages = Array.from(pages, normalizePage);
  return { name, open, pages };
}
function normalizePage(spec) {
  let { name, path } = spec;
  name = String(name);
  path = String(path);
  if (isAssetPath(path)) {
    const u = parseRelativeUrl(join("/", path));
    let { pathname } = u;
    pathname = pathname.replace(/\.html$/i, "");
    pathname = pathname.replace(/\/$/, "/index");
    path = pathname + u.search + u.hash;
  }
  return { name, path };
}
function normalizeInterpreters(spec) {
  return Object.fromEntries(
    Object.entries(spec ?? {}).map(([key, value]) => {
      return [String(key), value == null ? null : Array.from(value, String)];
    })
  );
}
function normalizeToc(spec) {
  if (typeof spec === "boolean")
    spec = { show: spec };
  let { label = "Contents", show = true } = spec;
  label = String(label);
  show = Boolean(show);
  return { label, show };
}
function mergeToc(spec = {}, toc) {
  const { label = toc.label, show = toc.show } = spec;
  return { label, show };
}
function mergeStyle(path, style, theme, defaultStyle) {
  return style === void 0 && theme === void 0 ? defaultStyle : style === null ? null : style !== void 0 ? { path: resolvePath(path, style) } : theme === void 0 ? defaultStyle : { theme };
}
export {
  mergeStyle,
  mergeToc,
  normalizeConfig,
  normalizeTheme,
  readConfig,
  setCurrentDate
};
