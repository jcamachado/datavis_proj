---
title: 2023 Spotify Streams
---

# Maiores Sucessos do Spotify em 2023 ðŸŽµ

## Existe alguma caracterÃ­stica que faz uma mÃºsica ter mais chance de se tornar popular?

Para analisar quais caracterÃ­sticas podem aumentar as chances de uma mÃºsica se tornar popular no Spotify, Ã© necessÃ¡rio considerar uma combinaÃ§Ã£o de atributos tÃ©cnicos, musicais e metadados associados Ã s faixas.

## PrÃ©-Processamento dos Dados
O dataset jÃ¡ estÃ¡ com os streams como atributo numÃ©rico e em ordem decrescente. Foi necessÃ¡rio realizar este prÃ© processamento devido Ã  atributos ausentes de uma instÃ¢ncia. AlÃ©m disso, as colunas 'key' e 'in_shazam_charts' tambÃ©m possuem atributos ausentes, entÃ£o Ã© necessÃ¡rio atenÃ§Ã£o ao analisÃ¡-las.


```js
// O dataset jÃ¡ estÃ¡ com os streams como atributo numÃ©rico e em ordem decrescente
const Spotify = FileAttachment("spotify-2023.csv").csv()
```

```js
const dataToDisplay = Spotify.map(d => ({
  TrackName: d['track_name'],
  'Streams (M)': (d['streams']/ 1000000)
}));
```

```js
Inputs.table(dataToDisplay)
```

# Mostrando os artistas mais ouvidos

```js
async function artistCounts() {

  // Separando os artistas para contabilizar os streams individualmente
  const expandedArtists = Spotify.flatMap(d => 
    d['artist(s)_name'].split(', ').map(artist => ({
    artist: artist,
    streams_in_millions: (d['streams']/ 1000000)
    }))
  );

  const artistStreams = {}

  expandedArtists.forEach(artistData => {
  // Verifica se o artista jÃ¡ existe no objeto
    if (artistStreams.hasOwnProperty(artistData.artist)) {
      // Se jÃ¡ existe, soma os streams
      artistStreams[artistData.artist] += artistData.streams_in_millions;
    } else {
      // Se nÃ£o existe, inicializa com o valor atual
      artistStreams[artistData.artist] = artistData.streams_in_millions;
    }
  })

  const artistArray = Object.entries(artistStreams).map(([artist, streams]) => {
    return {artist, streams};
  });

  artistArray.sort((a, b) => b.streams - a.streams);
  

return artistArray

};

```
```js
const artistCount = await artistCounts();
```

```js
display(artistCount);
```

```js
Inputs.table(artistCount)
```

# MÃºsicas Mais Tocadas no Spotify em 2023

<!-- ```js
let range = view(Inputs.range([10, 32], {label: "NÃºmero de mÃºsicas:", step: 1, value: 10}))
``` -->
<!-- 
```js
vl.layer(
  // Camada de barras
  vl.markBar()
    .data(Spotify.slice(0,range)).title({"text": "MÃºsicas Mais Tocadas 2023", fontSize: 20})
    .encode(
      vl.x().fieldQ("streams").title("Streams"),
      vl.y().fieldN("track_name").title("Track Name").sort(null).axis(null),
      vl.text().fieldN("track_name"),
      vl.color().fieldN("track_name").scale({scheme: 'category10'}).legend(null) // Esquema de cores opcional
    ),
  // Camada de texto
  vl.markText({
    align: 'right',
    baseline: 'middle',
    dx: -10,  // Deslocamento horizontal do texto para a direita, ajuste conforme necessÃ¡rio
    color: 'white'}
  )
    .data(Spotify.slice(0,range))
    .encode(
      vl.x().fieldQ("streams"),
      vl.y().fieldN("track_name").sort(null),
      vl.text().fieldN("track_name")
    ),

    vl.markText({
    align: 'left',
    baseline: 'middle',
    dir: 'rtl',
    dx: -340,  // Deslocamento horizontal do texto para a direita, ajuste conforme necessÃ¡rio
    color: 'white'})
    .data(Spotify.slice(0,range))
    .encode(
      vl.x().fieldQ(0),
      vl.y().fieldN("track_name").sort(null),
      vl.text().fieldN("artist(s)_name")
    )
).width(700).height(range * 20).render()
``` -->

```js
const random = d3.randomLcg(42);
const x = Array.from({length: 500}, random);
const y = Array.from({length: 500}, random);
const chart = Plot.voronoi(x, {x, y, fill: x}).plot({nice: true});

display(chart);
```

```js
Plot.plot({
  r: {range: [0, 6]}, // generate slightly smaller dots
  marks: [
    Plot.dot(olympians, Plot.bin({r: "count"}, {x: "in_spotify_charts", y: "bpm"}))
  ]
})

```